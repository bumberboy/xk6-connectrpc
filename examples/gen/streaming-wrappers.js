// Code generated by protoc-gen-k6-connectrpc. DO NOT EDIT.
//
// Streaming wrapper classes for k6 Connect-RPC

// Base streaming wrapper class
export class StreamWrapper {
  constructor(stream, options = {}) {
    this.stream = stream;
    this.options = options;
    this._setupErrorHandling();
  }

  _setupErrorHandling() {
    this.stream.on('error', (err) => {
      console.error(`Stream error: ${err.code} - ${err.message}`);
      if (this.options.onError) {
        this.options.onError(err);
      }
    });
  }
}

// Server streaming wrapper
export class ServerStreamWrapper extends StreamWrapper {
  constructor(stream, options) {
    super(stream, options);
    this._messageQueue = [];
    this._callbacks = [];
    this._onEndCallbacks = [];
    this._onErrorCallbacks = [];
    this._isEnded = false;
    this._setupHandlers();
  }

  // Event-based pattern (like original xk6-connectrpc)
  on(event, callback) {
    if (event === 'data') {
      this._callbacks.push(callback);
      // Process any queued messages
      while (this._messageQueue.length > 0) {
        callback(this._messageQueue.shift());
      }
    } else if (event === 'end') {
      if (this._isEnded) {
        callback();
      } else {
        this._onEndCallbacks.push(callback);
      }
    } else if (event === 'error') {
      this._onErrorCallbacks.push(callback);
    }
    return this;
  }

  // Callback-based iteration
  forEach(callback) {
    this.on('data', callback);
    return this;
  }

  // Event-style convenience methods
  onEnd(callback) {
    return this.on('end', callback);
  }

  onError(callback) {
    return this.on('error', callback);
  }

  // Promise-based collection of all messages
  collect() {
    return new Promise((resolve, reject) => {
      const messages = [];
      
      this.on('data', (message) => {
        messages.push(message);
      });
      
      this.on('end', () => {
        resolve(messages);
      });
      
      this.on('error', (err) => {
        reject(err);
      });
    });
  }

  _setupHandlers() {
    this.stream.on('data', (message) => {
      if (this._callbacks.length > 0) {
        this._callbacks.forEach(callback => callback(message));
      } else {
        this._messageQueue.push(message);
      }
    });

    this.stream.on('end', () => {
      this._isEnded = true;
      this._onEndCallbacks.forEach(callback => callback());
    });

    this.stream.on('error', (err) => {
      this._isEnded = true;
      this._onErrorCallbacks.forEach(callback => callback(err));
    });
  }
}

// Client streaming wrapper
export class ClientStreamWrapper extends StreamWrapper {
  constructor(stream, options) {
    super(stream, options);
    this._response = null;
    this._responsePromise = new Promise((resolve, reject) => {
      this._resolveResponse = resolve;
      this._rejectResponse = reject;
    });
    this._responseCallbacks = [];
    this._errorCallbacks = [];
    this._setupResponseHandlers();
  }

  write(message) {
    try {
      this.stream.write(message);
    } catch (err) {
      this._errorCallbacks.forEach(callback => callback(err));
      throw err;
    }
    return this;
  }

  close() {
    this.stream.end();
    return this;
  }

  // Event-based response handling
  onResponse(callback) {
    if (this._response) {
      callback(this._response);
    } else {
      this._responseCallbacks.push(callback);
    }
    return this;
  }

  onError(callback) {
    this._errorCallbacks.push(callback);
    return this;
  }

  // Promise-based response (for async/await when supported)
  response() {
    return this._responsePromise;
  }

  _setupResponseHandlers() {
    this.stream.on('data', (response) => {
      this._response = response;
      this._responseCallbacks.forEach(callback => callback(response));
    });

    this.stream.on('end', () => {
      this._resolveResponse(this._response);
    });

    this.stream.on('error', (err) => {
      this._errorCallbacks.forEach(callback => callback(err));
      this._rejectResponse(err);
    });
  }
}

// Bidirectional streaming wrapper
export class BidiStreamWrapper extends StreamWrapper {
  constructor(stream, options) {
    super(stream, options);
    this._messageQueue = [];
    this._callbacks = [];
    this._onEndCallbacks = [];
    this._onErrorCallbacks = [];
    this._isEnded = false;
    this._setupReadHandlers();
  }

  // Event-based pattern for reading
  on(event, callback) {
    if (event === 'data') {
      this._callbacks.push(callback);
      // Process any queued messages
      while (this._messageQueue.length > 0) {
        callback(this._messageQueue.shift());
      }
    } else if (event === 'end') {
      if (this._isEnded) {
        callback();
      } else {
        this._onEndCallbacks.push(callback);
      }
    } else if (event === 'error') {
      this._onErrorCallbacks.push(callback);
    }
    return this;
  }

  // Write to the stream
  write(message) {
    try {
      this.stream.write(message);
    } catch (err) {
      this._onErrorCallbacks.forEach(callback => callback(err));
      throw err;
    }
    return this;
  }

  // Close the stream
  close() {
    this.stream.end();
    return this;
  }

  // Convenience methods
  onEnd(callback) {
    return this.on('end', callback);
  }

  onError(callback) {
    return this.on('error', callback);
  }

  _setupReadHandlers() {
    this.stream.on('data', (message) => {
      if (this._callbacks.length > 0) {
        this._callbacks.forEach(callback => callback(message));
      } else {
        this._messageQueue.push(message);
      }
    });

    this.stream.on('end', () => {
      this._isEnded = true;
      this._onEndCallbacks.forEach(callback => callback());
    });

    this.stream.on('error', (err) => {
      this._isEnded = true;
      this._onErrorCallbacks.forEach(callback => callback(err));
    });
  }
}
