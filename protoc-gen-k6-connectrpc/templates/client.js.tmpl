{{- /*gotype: github.com/bumberboy/xk6-connectrpc/protoc-gen-k6-connectrpc/internal/javascript.TemplateData*/ -}}
// Code generated by protoc-gen-k6-connectrpc. DO NOT EDIT.
//
// Source: {{.File.Path}}
// Language: JavaScript

import connectrpc from 'k6/x/connectrpc';
{{if and .Config.StreamingWrappers .Config.ExternalWrappers -}}
import { 
  StreamWrapper, 
  ServerStreamWrapper, 
  ClientStreamWrapper, 
  BidiStreamWrapper 
} from '{{.StreamingWrappersPath}}';
{{else if .Config.StreamingWrappers}}
// Streaming wrapper classes
class StreamWrapper {
  constructor(stream, options = {}) {
    this.stream = stream;
    this.options = options;
    this._setupErrorHandling();
  }

  _setupErrorHandling() {
    this.stream.on('error', (err) => {
      console.error(`Stream error: ${err.code} - ${err.message}`);
      if (this.options.onError) {
        this.options.onError(err);
      }
    });
  }
}

class ServerStreamWrapper extends StreamWrapper {
  constructor(stream, options) {
    super(stream, options);
    this._messageQueue = [];
    this._callbacks = [];
    this._onEndCallbacks = [];
    this._onErrorCallbacks = [];
    this._isEnded = false;
    this._setupHandlers();
  }

  // Event-based pattern (like original xk6-connectrpc)
  on(event, callback) {
    if (event === 'data') {
      this._callbacks.push(callback);
      // Process any queued messages
      while (this._messageQueue.length > 0) {
        callback(this._messageQueue.shift());
      }
    } else if (event === 'end') {
      if (this._isEnded) {
        callback();
      } else {
        this._onEndCallbacks.push(callback);
      }
    } else if (event === 'error') {
      this._onErrorCallbacks.push(callback);
    }
    return this;
  }

  // Callback-based iteration
  forEach(callback) {
    this.on('data', callback);
    return this;
  }

  // Event-style convenience methods
  onEnd(callback) {
    return this.on('end', callback);
  }

  onError(callback) {
    return this.on('error', callback);
  }

  // Promise-based collection of all messages
  collect() {
    return new Promise((resolve, reject) => {
      const messages = [];
      
      this.on('data', (message) => {
        messages.push(message);
      });
      
      this.on('end', () => {
        resolve(messages);
      });
      
      this.on('error', (err) => {
        reject(err);
      });
    });
  }

  _setupHandlers() {
    this.stream.on('data', (message) => {
      if (this._callbacks.length > 0) {
        this._callbacks.forEach(callback => callback(message));
      } else {
        this._messageQueue.push(message);
      }
    });

    this.stream.on('end', () => {
      this._isEnded = true;
      this._onEndCallbacks.forEach(callback => callback());
    });

    this.stream.on('error', (err) => {
      this._isEnded = true;
      this._onErrorCallbacks.forEach(callback => callback(err));
    });
  }
}

class ClientStreamWrapper extends StreamWrapper {
  constructor(stream, options) {
    super(stream, options);
    this._response = null;
    this._responsePromise = new Promise((resolve, reject) => {
      this._resolveResponse = resolve;
      this._rejectResponse = reject;
    });
    this._responseCallbacks = [];
    this._errorCallbacks = [];
    this._setupResponseHandlers();
  }

  write(message) {
    try {
      this.stream.write(message);
    } catch (err) {
      this._errorCallbacks.forEach(callback => callback(err));
      throw err;
    }
    return this;
  }

  close() {
    this.stream.end();
    return this;
  }

  // Event-based response handling
  onResponse(callback) {
    if (this._response) {
      callback(this._response);
    } else {
      this._responseCallbacks.push(callback);
    }
    return this;
  }

  onError(callback) {
    this._errorCallbacks.push(callback);
    return this;
  }

  // Promise-based response (for async/await when supported)
  response() {
    return this._responsePromise;
  }

  _setupResponseHandlers() {
    this.stream.on('data', (response) => {
      this._response = response;
      this._responseCallbacks.forEach(callback => callback(response));
    });

    this.stream.on('end', () => {
      this._resolveResponse(this._response);
    });

    this.stream.on('error', (err) => {
      this._errorCallbacks.forEach(callback => callback(err));
      this._rejectResponse(err);
    });
  }
}

class BidiStreamWrapper extends StreamWrapper {
  constructor(stream, options) {
    super(stream, options);
    this._messageQueue = [];
    this._callbacks = [];
    this._onEndCallbacks = [];
    this._onErrorCallbacks = [];
    this._isEnded = false;
    this._setupReadHandlers();
  }

  // Event-based pattern for reading
  on(event, callback) {
    if (event === 'data') {
      this._callbacks.push(callback);
      // Process any queued messages
      while (this._messageQueue.length > 0) {
        callback(this._messageQueue.shift());
      }
    } else if (event === 'end') {
      if (this._isEnded) {
        callback();
      } else {
        this._onEndCallbacks.push(callback);
      }
    } else if (event === 'error') {
      this._onErrorCallbacks.push(callback);
    }
    return this;
  }

  // Write to the stream
  write(message) {
    try {
      this.stream.write(message);
    } catch (err) {
      this._onErrorCallbacks.forEach(callback => callback(err));
      throw err;
    }
    return this;
  }

  // Close the stream
  close() {
    this.stream.end();
    return this;
  }

  // Convenience methods
  onEnd(callback) {
    return this.on('end', callback);
  }

  onError(callback) {
    return this.on('error', callback);
  }

  _setupReadHandlers() {
    this.stream.on('data', (message) => {
      if (this._callbacks.length > 0) {
        this._callbacks.forEach(callback => callback(message));
      } else {
        this._messageQueue.push(message);
      }
    });

    this.stream.on('end', () => {
      this._isEnded = true;
      this._onEndCallbacks.forEach(callback => callback());
    });

    this.stream.on('error', (err) => {
      this._isEnded = true;
      this._onErrorCallbacks.forEach(callback => callback(err));
    });
  }
}

{{end -}}
{{range .Services -}}
{{$service := .}}

// Constants for {{.Name}} service
export const {{.Name}}Constants = {
  SERVICE_NAME: "{{.FullName}}",
  METHODS: {
{{- range .Methods}}
    {{.ConstantName}}: "{{.ProcedurePath}}",
{{- end}}
  },
  METADATA: {
{{- range .Methods}}
    {{.ConstantName}}: {
      type: "{{.StreamType}}",
{{- if .HasIdempotency}}
      idempotency: "{{.IdempotencyLevel}}",
{{- end}}
{{- if .SuggestedTimeout}}
      timeout: "{{.SuggestedTimeout}}",
{{- end}}
    },
{{- end}}
  }
};

{{if $.Config.IncludeValidation -}}
// Validation helpers for {{.Name}} service
const {{.Name}}Validators = {
{{- range .Methods}}
  {{.Name}}: {
    request: (req) => {
{{- range .InputFields}}
{{- if .Required}}
      if ({{if .IsOptional}}req.{{.Name}} === undefined || {{end}}req.{{.Name}} === null{{if eq .Type "string"}} || req.{{.Name}} === ""{{end}}) {
        throw new Error('{{.Name}} is required');
      }
{{- end}}
{{- if .HasValidation}}
      {{.ValidationCode}}
{{- end}}
{{- end}}
      return req;
    }
  },
{{- end}}
};
{{end}}

{{if $.Config.IncludeMocks -}}
// Mock factories for {{.Name}} service
export const {{.Name}}Mocks = {
{{- range .Methods}}
  {{.Name}}Request: () => ({
{{- range .InputFields}}
    {{.Name}}: {{.MockValue}},
{{- end}}
  }),
  {{.Name}}Response: () => ({
{{- range .OutputFields}}
    {{.Name}}: {{.MockValue}},
{{- end}}
  }),
{{- end}}
};
{{end}}

// {{.Name}} client class
export class {{.Name}}{{$.Config.ClientSuffix}} {
  constructor(connectrpcClient, baseURL = '') {
    this.client = connectrpcClient;
    this.baseURL = baseURL.replace(/\/$/, '');
  }

{{- range .Methods}}
{{- if eq .StreamType "unary"}}

  /**
   * {{.Comment}}
   * @param {Object} request - The request object
   * @param {Object} options - Call options (timeout, headers, etc.)
   * @returns {Promise<Object>} The response object
   */
  {{.CamelName}}(request, options = {}) {
{{- if $.Config.IncludeValidation}}
    {{$service.Name}}Validators.{{.Name}}.request(request);
{{- end}}
    return this.client.invoke(
      {{$service.Name}}Constants.METHODS.{{.ConstantName}},
      request,
      {
        {{if .SuggestedTimeout}}timeout: '{{.SuggestedTimeout}}',{{else}}timeout: '30s',{{end}}
        ...options
      }
    );
  }
{{- else if eq .StreamType "server_stream"}}

  /**
   * {{.Comment}}
   * Server streaming method - returns stream wrapper with multiple consumption patterns
   * @param {Object} request - The request object
   * @param {Object} options - Call options
   * @returns {ServerStreamWrapper} Stream wrapper with .on(), .forEach(), .collect() methods
   */
  {{.CamelName}}(request, options = {}) {
{{- if $.Config.IncludeValidation}}
    {{$service.Name}}Validators.{{.Name}}.request(request);
{{- end}}
    const stream = new connectrpc.Stream(
      this.client, 
      {{$service.Name}}Constants.METHODS.{{.ConstantName}}
    );
    const wrapper = new ServerStreamWrapper(stream, options);
    stream.write(request);
    stream.end();
    return wrapper;
  }
{{- else if eq .StreamType "client_stream"}}

  /**
   * {{.Comment}}
   * Client streaming method - returns stream wrapper
   * @param {Object} options - Call options
   * @returns {ClientStreamWrapper} Stream wrapper for sending multiple requests
   */
  {{.CamelName}}Stream(options = {}) {
    const stream = new connectrpc.Stream(
      this.client,
      {{$service.Name}}Constants.METHODS.{{.ConstantName}}
    );
    return new ClientStreamWrapper(stream, options);
  }
{{- else if eq .StreamType "bidi_stream"}}

  /**
   * {{.Comment}}
   * Bidirectional streaming method - returns stream wrapper
   * @param {Object} options - Call options
   * @returns {BidiStreamWrapper} Stream wrapper for bidirectional communication
   */
  {{.CamelName}}Stream(options = {}) {
    const stream = new connectrpc.Stream(
      this.client,
      {{$service.Name}}Constants.METHODS.{{.ConstantName}}
    );
    return new BidiStreamWrapper(stream, options);
  }
{{- end}}
{{- end}}
}
{{- end}}

{{if .EmbeddedProtoset}}
// Auto-load embedded proto definitions
try {
  connectrpc.loadEmbeddedProtoset('{{.EmbeddedProtoset}}');
} catch (err) {
  console.warn('Failed to auto-load embedded proto definitions:', err.message);
  console.warn('You may need to call connectrpc.loadProtos() or connectrpc.loadProtoset() manually');
}
{{end}} 